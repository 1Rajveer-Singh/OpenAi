import asyncio
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
import json
from loguru import logger
import pandas as pd
import numpy as np
from sqlalchemy.orm import Session
from app.models.database import get_db
from app.models.schemas import InventoryItem, Transaction

class InventoryAgent:
    """
    AI Agent specialized in inventory management, demand forecasting,
    and supplier management for Indian MSMEs.
    """
    
    def __init__(self, openai_client):
        self.openai_client = openai_client
        self.name = "Inventory Assistant"
        self.expertise = [
            "Stock level monitoring",
            "Demand forecasting", 
            "Seasonal trend analysis",
            "Festival demand prediction",
            "Supplier recommendations",
            "Expiry management"
        ]
        
    async def initialize(self):
        """Initialize the inventory agent"""
        logger.info("üè™ Initializing Inventory Agent")
        # Load seasonal patterns, festival data, etc.
        self.seasonal_patterns = self._load_seasonal_patterns()
        self.festival_calendar = self._load_festival_calendar()
        
    async def process_query(
        self, 
        user_id: int, 
        query: str, 
        intent: Dict[str, Any], 
        language: str
    ) -> Dict[str, Any]:
        """Process inventory-related queries"""
        try:
            entities = intent.get("entities", [])
            
            # Determine specific inventory action
            if any(word in query.lower() for word in ["stock", "‡§∏‡•ç‡§ü‡•â‡§ï", "inventory", "‡§≠‡§Ç‡§°‡§æ‡§∞"]):
                return await self._handle_stock_inquiry(user_id, query, language)
            elif any(word in query.lower() for word in ["forecast", "predict", "‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø‡§µ‡§æ‡§£‡•Ä", "‡§™‡•Ç‡§∞‡•ç‡§µ‡§æ‡§®‡•Å‡§Æ‡§æ‡§®"]):
                return await self._handle_demand_forecast(user_id, query, language)
            elif any(word in query.lower() for word in ["supplier", "‡§∏‡§™‡•ç‡§≤‡§æ‡§Ø‡§∞", "vendor", "‡§µ‡§ø‡§ï‡•ç‡§∞‡•á‡§§‡§æ"]):
                return await self._handle_supplier_query(user_id, query, language)
            elif any(word in query.lower() for word in ["expiry", "‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä", "expire", "‡§∏‡§Æ‡§æ‡§™‡•ç‡§§"]):
                return await self._handle_expiry_check(user_id, query, language)
            else:
                return await self._handle_general_inventory_query(user_id, query, language)
                
        except Exception as e:
            logger.error(f"Inventory agent query processing failed: {e}")
            return {
                "text": "‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§≤‡•á‡§®‡•á ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à" if language == "hi" else "Having trouble with stock information",
                "agent": "inventory",
                "success": False
            }
    
    async def get_insights(self, user_id: int) -> Dict[str, Any]:
        """Get comprehensive inventory insights"""
        try:
            db = next(get_db())
            
            # Get current inventory status
            inventory_items = db.query(InventoryItem).filter(
                InventoryItem.owner_id == user_id
            ).all()
            
            insights = {
                "total_items": len(inventory_items),
                "low_stock_items": [],
                "high_demand_predictions": [],
                "seasonal_recommendations": [],
                "expiry_alerts": [],
                "supplier_recommendations": []
            }
            
            for item in inventory_items:
                # Check low stock
                if item.current_stock <= item.min_stock_level:
                    insights["low_stock_items"].append({
                        "name": item.name,
                        "current_stock": item.current_stock,
                        "min_level": item.min_stock_level,
                        "urgency": "high" if item.current_stock < item.min_stock_level * 0.5 else "medium"
                    })
                
                # Check expiry
                if item.expiry_date and item.expiry_date <= datetime.now() + timedelta(days=7):
                    insights["expiry_alerts"].append({
                        "name": item.name,
                        "expiry_date": item.expiry_date.isoformat(),
                        "days_remaining": (item.expiry_date - datetime.now()).days
                    })
            
            # Generate demand predictions
            insights["high_demand_predictions"] = await self._predict_high_demand_items(user_id, db)
            
            # Generate seasonal recommendations
            insights["seasonal_recommendations"] = await self._get_seasonal_recommendations()
            
            return insights
            
        except Exception as e:
            logger.error(f"Failed to get inventory insights: {e}")
            return {"error": "Failed to generate inventory insights"}
    
    async def _handle_stock_inquiry(self, user_id: int, query: str, language: str) -> Dict[str, Any]:
        """Handle stock level inquiries"""
        try:
            db = next(get_db())
            
            # Get current stock summary
            inventory_items = db.query(InventoryItem).filter(
                InventoryItem.owner_id == user_id
            ).all()
            
            total_items = len(inventory_items)
            low_stock_count = sum(1 for item in inventory_items if item.current_stock <= item.min_stock_level)
            
            if language == "hi":
                response_text = f"""
                üìä ‡§Ü‡§™‡§ï‡§æ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§∏‡•ç‡§•‡§ø‡§§‡§ø:
                
                ‡§ï‡•Å‡§≤ ‡§Ü‡§á‡§ü‡§Æ: {total_items}
                ‡§ï‡§Æ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§µ‡§æ‡§≤‡•á ‡§Ü‡§á‡§ü‡§Æ: {low_stock_count}
                
                """
                
                if low_stock_count > 0:
                    low_stock_items = [item for item in inventory_items if item.current_stock <= item.min_stock_level][:3]
                    response_text += "‡§§‡•Å‡§∞‡§Ç‡§§ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡§∞‡•á‡§Ç:\n"
                    for item in low_stock_items:
                        response_text += f"‚Ä¢ {item.name}: {item.current_stock} ‡§¨‡§ö‡•á ‡§π‡•à‡§Ç\n"
            else:
                response_text = f"""
                üìä Your Stock Status:
                
                Total Items: {total_items}
                Low Stock Items: {low_stock_count}
                
                """
                
                if low_stock_count > 0:
                    low_stock_items = [item for item in inventory_items if item.current_stock <= item.min_stock_level][:3]
                    response_text += "Order Immediately:\n"
                    for item in low_stock_items:
                        response_text += f"‚Ä¢ {item.name}: {item.current_stock} remaining\n"
            
            return {
                "text": response_text,
                "agent": "inventory",
                "success": True,
                "data": {
                    "total_items": total_items,
                    "low_stock_count": low_stock_count
                }
            }
            
        except Exception as e:
            logger.error(f"Stock inquiry failed: {e}")
            return {
                "text": "‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à" if language == "hi" else "Stock information not available",
                "agent": "inventory", 
                "success": False
            }
    
    async def _handle_demand_forecast(self, user_id: int, query: str, language: str) -> Dict[str, Any]:
        """Handle demand forecasting requests"""
        try:
            # Get historical sales data
            db = next(get_db())
            
            # Simplified demand forecasting using seasonal patterns
            current_month = datetime.now().month
            upcoming_festivals = self._get_upcoming_festivals()
            
            forecast_text = "üîÆ ‡§Æ‡§æ‡§Ç‡§ó ‡§™‡•Ç‡§∞‡•ç‡§µ‡§æ‡§®‡•Å‡§Æ‡§æ‡§®:\n\n" if language == "hi" else "üîÆ Demand Forecast:\n\n"
            
            if upcoming_festivals:
                festival = upcoming_festivals[0]
                if language == "hi":
                    forecast_text += f"‡§Ü‡§ó‡§æ‡§Æ‡•Ä {festival['name']} ‡§ï‡•á ‡§≤‡§ø‡§è:\n"
                    forecast_text += f"‚Ä¢ ‡§Æ‡§ø‡§†‡§æ‡§à ‡§î‡§∞ ‡§®‡§Æ‡§ï‡•Ä‡§® ‡§ï‡•Ä ‡§Æ‡§æ‡§Ç‡§ó 150% ‡§¨‡§¢‡§º‡•á‡§ó‡•Ä\n"
                    forecast_text += f"‚Ä¢ ‡§∏‡§ú‡§æ‡§µ‡§ü ‡§ï‡§æ ‡§∏‡§æ‡§Æ‡§æ‡§® 200% ‡§¨‡§¢‡§º‡•á‡§ó‡§æ\n"
                    forecast_text += f"‚Ä¢ ‡§¶‡•à‡§®‡§ø‡§ï ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡•Ä ‡§ö‡•Ä‡§ú‡•ã‡§Ç ‡§Æ‡•á‡§Ç 30% ‡§µ‡•É‡§¶‡•ç‡§ß‡§ø\n"
                else:
                    forecast_text += f"For upcoming {festival['name']}:\n"
                    forecast_text += f"‚Ä¢ Sweets and snacks demand will increase by 150%\n"
                    forecast_text += f"‚Ä¢ Decoration items will increase by 200%\n"
                    forecast_text += f"‚Ä¢ Daily essentials will see 30% growth\n"
            
            # Add seasonal predictions
            seasonal_prediction = self._get_seasonal_prediction(current_month)
            forecast_text += f"\n{seasonal_prediction[language]}"
            
            return {
                "text": forecast_text,
                "agent": "inventory",
                "success": True,
                "data": {
                    "upcoming_festivals": upcoming_festivals,
                    "seasonal_factors": seasonal_prediction
                }
            }
            
        except Exception as e:
            logger.error(f"Demand forecast failed: {e}")
            return {
                "text": "‡§Æ‡§æ‡§Ç‡§ó ‡§™‡•Ç‡§∞‡•ç‡§µ‡§æ‡§®‡•Å‡§Æ‡§æ‡§® ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à" if language == "hi" else "Demand forecast not available",
                "agent": "inventory",
                "success": False
            }
    
    async def _handle_supplier_query(self, user_id: int, query: str, language: str) -> Dict[str, Any]:
        """Handle supplier-related queries"""
        suppliers_text = """
        üè≠ ‡§∏‡•Å‡§ù‡§æ‡§è ‡§ó‡§è ‡§∏‡§™‡•ç‡§≤‡§æ‡§Ø‡§∞:
        
        ‚Ä¢ ‡§∞‡§æ‡§ú ‡§ü‡•ç‡§∞‡•á‡§°‡§∞‡•ç‡§∏ - üìû 9876543210
          ‡§ï‡§Æ ‡§ï‡•Ä‡§Æ‡§§, ‡§Ö‡§ö‡•ç‡§õ‡•Ä ‡§ó‡•Å‡§£‡§µ‡§§‡•ç‡§§‡§æ
          
        ‚Ä¢ ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§π‡•ã‡§≤‡§∏‡•á‡§≤ - üìû 9765432109  
          ‡§§‡•á‡§ú‡§º ‡§°‡§ø‡§≤‡•Ä‡§µ‡§∞‡•Ä, 2 ‡§¶‡§ø‡§®
          
        ‚Ä¢ ‡§ó‡•Å‡§™‡•ç‡§§‡§æ ‡§∏‡•ç‡§ü‡•ã‡§∞‡•ç‡§∏ - üìû 9654321098
          ‡§¨‡§≤‡•ç‡§ï ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§Æ‡•á‡§Ç ‡§õ‡•Ç‡§ü
        """ if language == "hi" else """
        üè≠ Recommended Suppliers:
        
        ‚Ä¢ Raj Traders - üìû 9876543210
          Low prices, good quality
          
        ‚Ä¢ Sharma Wholesale - üìû 9765432109
          Fast delivery, 2 days
          
        ‚Ä¢ Gupta Stores - üìû 9654321098
          Bulk order discounts
        """
        
        return {
            "text": suppliers_text,
            "agent": "inventory",
            "success": True
        }
    
    async def _handle_expiry_check(self, user_id: int, query: str, language: str) -> Dict[str, Any]:
        """Handle expiry date checks"""
        try:
            db = next(get_db())
            
            # Get items expiring soon
            upcoming_expiry = db.query(InventoryItem).filter(
                InventoryItem.owner_id == user_id,
                InventoryItem.expiry_date.isnot(None),
                InventoryItem.expiry_date <= datetime.now() + timedelta(days=7)
            ).all()
            
            if not upcoming_expiry:
                return {
                    "text": "‡§ï‡•ã‡§à ‡§ö‡•Ä‡§ú‡§º ‡§ú‡§≤‡•ç‡§¶‡•Ä ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∞‡§π‡•Ä! üëç" if language == "hi" else "Nothing expiring soon! üëç",
                    "agent": "inventory",
                    "success": True
                }
            
            expiry_text = "‚ö†Ô∏è ‡§ú‡§≤‡•ç‡§¶‡•Ä ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞ ‡§π‡•ã‡§®‡•á ‡§µ‡§æ‡§≤‡•Ä ‡§ö‡•Ä‡§ú‡§º‡•á‡§Ç:\n\n" if language == "hi" else "‚ö†Ô∏è Items Expiring Soon:\n\n"
            
            for item in upcoming_expiry[:5]:
                days_left = (item.expiry_date - datetime.now()).days
                if language == "hi":
                    expiry_text += f"‚Ä¢ {item.name}: {days_left} ‡§¶‡§ø‡§® ‡§¨‡§ö‡•á\n"
                else:
                    expiry_text += f"‚Ä¢ {item.name}: {days_left} days left\n"
            
            return {
                "text": expiry_text,
                "agent": "inventory", 
                "success": True,
                "data": {"expiring_items": len(upcoming_expiry)}
            }
            
        except Exception as e:
            logger.error(f"Expiry check failed: {e}")
            return {
                "text": "‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à" if language == "hi" else "Expiry information not available",
                "agent": "inventory",
                "success": False
            }
    
    async def _handle_general_inventory_query(self, user_id: int, query: str, language: str) -> Dict[str, Any]:
        """Handle general inventory queries"""
        return {
            "text": "‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•á ‡§∏‡•ç‡§ü‡•â‡§ï, ‡§Æ‡§æ‡§Ç‡§ó ‡§™‡•Ç‡§∞‡•ç‡§µ‡§æ‡§®‡•Å‡§Æ‡§æ‡§®, ‡§î‡§∞ ‡§∏‡§™‡•ç‡§≤‡§æ‡§Ø‡§∞ ‡§ï‡•Ä ‡§Æ‡§¶‡§¶ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Ç‡•§ ‡§ï‡•Å‡§õ ‡§ñ‡§æ‡§∏ ‡§ú‡§æ‡§®‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?" if language == "hi" 
                   else "I can help with your stock, demand forecasting, and suppliers. What would you like to know?",
            "agent": "inventory",
            "success": True
        }
    
    def _load_seasonal_patterns(self) -> Dict[str, Any]:
        """Load seasonal demand patterns for India"""
        return {
            "winter": {"months": [11, 12, 1, 2], "high_demand": ["warm_clothes", "heaters", "medicines"]},
            "summer": {"months": [3, 4, 5, 6], "high_demand": ["cooling_items", "cold_drinks", "fans"]},
            "monsoon": {"months": [7, 8, 9], "high_demand": ["umbrellas", "rain_gear", "warm_food"]},
            "festive": {"months": [10, 11], "high_demand": ["sweets", "decorations", "gifts"]}
        }
    
    def _load_festival_calendar(self) -> List[Dict[str, Any]]:
        """Load Indian festival calendar for demand prediction"""
        return [
            {"name": "Diwali", "month": 11, "high_demand": ["sweets", "lights", "gifts"]},
            {"name": "Holi", "month": 3, "high_demand": ["colors", "sweets", "snacks"]},
            {"name": "Dussehra", "month": 10, "high_demand": ["sweets", "clothes", "decorations"]},
            {"name": "Eid", "month": 4, "high_demand": ["sweets", "clothes", "meat"]},
            {"name": "Christmas", "month": 12, "high_demand": ["cakes", "decorations", "gifts"]}
        ]
    
    def _get_upcoming_festivals(self) -> List[Dict[str, Any]]:
        """Get upcoming festivals in next 30 days"""
        current_month = datetime.now().month
        return [f for f in self.festival_calendar if f["month"] >= current_month][:2]
    
    def _get_seasonal_prediction(self, month: int) -> Dict[str, str]:
        """Get seasonal predictions based on current month"""
        if month in [11, 12, 1, 2]:
            return {
                "hi": "‡§∏‡§∞‡•ç‡§¶‡•Ä ‡§ï‡§æ ‡§Æ‡•å‡§∏‡§Æ: ‡§ó‡§∞‡•ç‡§Æ ‡§ï‡§™‡§°‡§º‡•á ‡§î‡§∞ ‡§π‡•Ä‡§ü‡§∞ ‡§ï‡•Ä ‡§Æ‡§æ‡§Ç‡§ó ‡§¨‡§¢‡§º‡•á‡§ó‡•Ä",
                "en": "Winter season: Demand for warm clothes and heaters will increase"
            }
        elif month in [3, 4, 5, 6]:
            return {
                "hi": "‡§ó‡§∞‡•ç‡§Æ‡•Ä ‡§ï‡§æ ‡§Æ‡•å‡§∏‡§Æ: ‡§†‡§Ç‡§°‡•á ‡§™‡•á‡§Ø ‡§î‡§∞ ‡§™‡§Ç‡§ñ‡•á ‡§ï‡•Ä ‡§Æ‡§æ‡§Ç‡§ó ‡§¨‡§¢‡§º‡•á‡§ó‡•Ä", 
                "en": "Summer season: Demand for cold drinks and fans will increase"
            }
        elif month in [7, 8, 9]:
            return {
                "hi": "‡§¨‡§æ‡§∞‡§ø‡§∂ ‡§ï‡§æ ‡§Æ‡•å‡§∏‡§Æ: ‡§õ‡§æ‡§§‡•á ‡§î‡§∞ ‡§∞‡•á‡§® ‡§ó‡§ø‡§Ø‡§∞ ‡§ï‡•Ä ‡§Æ‡§æ‡§Ç‡§ó ‡§¨‡§¢‡§º‡•á‡§ó‡•Ä",
                "en": "Monsoon season: Demand for umbrellas and rain gear will increase"
            }
        else:
            return {
                "hi": "‡§§‡•ç‡§Ø‡•ã‡§π‡§æ‡§∞‡•Ä ‡§Æ‡•å‡§∏‡§Æ: ‡§Æ‡§ø‡§†‡§æ‡§à ‡§î‡§∞ ‡§∏‡§ú‡§æ‡§µ‡§ü ‡§ï‡§æ ‡§∏‡§æ‡§Æ‡§æ‡§® ‡§ö‡§æ‡§π‡§ø‡§è ‡§π‡•ã‡§ó‡§æ",
                "en": "Festival season: Sweets and decorations will be in demand"
            }
    
    async def _predict_high_demand_items(self, user_id: int, db: Session) -> List[Dict[str, Any]]:
        """Predict items that will have high demand"""
        # Simplified prediction based on seasonal patterns
        current_month = datetime.now().month
        seasonal_items = []
        
        if current_month in [11, 12, 1, 2]:  # Winter
            seasonal_items = [
                {"item": "Warm Clothes", "predicted_increase": "40%"},
                {"item": "Heaters", "predicted_increase": "60%"},
                {"item": "Hot Beverages", "predicted_increase": "35%"}
            ]
        elif current_month in [3, 4, 5, 6]:  # Summer  
            seasonal_items = [
                {"item": "Cold Drinks", "predicted_increase": "50%"},
                {"item": "Fans/Coolers", "predicted_increase": "45%"},
                {"item": "Summer Clothes", "predicted_increase": "30%"}
            ]
        
        return seasonal_items
    
    async def _get_seasonal_recommendations(self) -> List[str]:
        """Get seasonal business recommendations"""
        current_month = datetime.now().month
        
        if current_month in [11, 12, 1, 2]:
            return [
                "Stock up on warm clothing and blankets",
                "Increase inventory of hot beverages",
                "Prepare for winter medicine demand"
            ]
        elif current_month in [3, 4, 5, 6]:
            return [
                "Increase cold drinks and ice cream stock",
                "Stock cooling appliances",
                "Prepare summer clothing inventory"
            ]
        else:
            return [
                "Maintain balanced inventory",
                "Monitor fast-moving items",
                "Plan for upcoming seasonal changes"
            ]